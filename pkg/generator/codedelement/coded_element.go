// Copyright 2020 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Package codedelement contains functionality to generate Coded Elements that have a Code and a Description.
package codedelement

import (
	"math/rand"
	"time"

	"github.com/google/simhospital/pkg/clock"
	"github.com/google/simhospital/pkg/config"
	"github.com/google/simhospital/pkg/ir"
	"github.com/google/simhospital/pkg/pathway"
	"github.com/google/simhospital/pkg/sample"
)

// CodeDescriptionMapping contains a mapping between code and description,
// to make the lookup more efficient.
type CodeDescriptionMapping struct {
	codeToDescription map[string]string
	descriptionToCode map[string]string
}

// Add adds a code-description pair to the CodeDescriptionMapping.
func (m *CodeDescriptionMapping) Add(code string, description string) {
	m.codeToDescription[code] = description
	m.descriptionToCode[description] = code
}

// deriveCodeAndDescription derives the code from the description of the description from the code,
// depending on the parameters specified.
// If the code is not specified (ie: empty string), it derives it from the description, and if the description
// is not specified (ie: empty string), it derives it from the code.
// Returns both: code and the description.
func (m *CodeDescriptionMapping) deriveCodeAndDescription(code string, description string) (string, string) {
	if code == "" {
		code = m.descriptionToCode[description]
	}
	if description == "" {
		description = m.codeToDescription[code]
	}
	return code, description
}

// NewCodeDescriptionMapping initializes an empty CodeDescriptionMapping structure.
func NewCodeDescriptionMapping() *CodeDescriptionMapping {
	return &CodeDescriptionMapping{
		codeToDescription: map[string]string{},
		descriptionToCode: map[string]string{},
	}
}

// Generator provides functionality to derive random coded element with some probability distribution.
type Generator struct {
	// contains a distribution of the coded elements, which will be used
	// when generating the random CodedElement in Random() function.
	*sample.DiscreteDistribution

	// mapping contains mapping from the code to the descriptions and the other way round,
	// for efficient lookups.
	mapping *CodeDescriptionMapping

	// types contains the list of all possible types, which will be used
	// to generated the random type in RandomType() function.
	types []string

	clock         clock.Clock
	dateGenerator DateGenerator
}

// Random returns a random coded element with some probability distribution.
func (g *Generator) Random() *ir.CodedElement {
	e := g.DiscreteDistribution.Random()
	if e == nil {
		return nil
	}
	return e.(*ir.CodedElement)
}

// RandomType returns a random type value, where each value has an equal probability to be selected.
func (g *Generator) RandomType() string {
	return g.types[rand.Intn(len(g.types))]
}

// DeriveCodeAndDescription returns underlying CodeDescriptionMapping.
func (g *Generator) DeriveCodeAndDescription(key string, desc string) (string, string) {
	return g.mapping.deriveCodeAndDescription(key, desc)
}

// nullTimeOrRandom returns a NullTime value given a pathway.DateTime value.
// If pathway.DateTime is null, it returns a random time generated by DateGenerator.
func (g *Generator) nullTimeOrRandom(dt *pathway.DateTime) ir.NullTime {
	if dt == nil {
		return g.dateGenerator.Random(g.clock.Now())
	}
	if t := dt.GetDateTime(g.clock.Now()); t != nil {
		return ir.NewValidTime(*t)
	}
	return ir.NewInvalidTime()
}

// newGenerator creates a Generator with the given coded elements and types.
func newGenerator(wrappedVals []config.MappableWeightedValue, types []string, c clock.Clock, dg DateGenerator) *Generator {
	weightVals := make([]sample.WeightedValue, 0, len(wrappedVals))
	mapping := NewCodeDescriptionMapping()
	for _, wv := range wrappedVals {
		mapping.Add(wv.Mapping.Key, wv.Mapping.Value)
		weightVals = append(weightVals, wv.WeightedVal)
	}

	return &Generator{
		DiscreteDistribution: &sample.DiscreteDistribution{
			WeightedValues: weightVals,
		},
		mapping:       mapping,
		types:         types,
		clock:         c,
		dateGenerator: dg,
	}
}

// DateGenerator is an interface for the generation of random dates.
type DateGenerator interface {
	// Random returns a random time based on the given time.
	Random(now time.Time) ir.NullTime
}

// SimpleDateGenerator is a generator of random dates.
type SimpleDateGenerator struct{}

// Random returns a random time, up to a year ago based on the given time.
func (s SimpleDateGenerator) Random(now time.Time) ir.NullTime {
	days := rand.Int63n(364) + 1
	timeFromNow := -time.Duration(days) * 24 * time.Hour
	return ir.NewValidTime(now.Add(timeFromNow))
}

// CodingSystemConvertor converts between the HL7 and FHIR representations of coding systems.
type CodingSystemConvertor struct {
	hl7ToFHIR map[string]string
}

// HL7ToFHIR returns the FHIR representation for the given HL7 name.
func (c CodingSystemConvertor) HL7ToFHIR(name string) string {
	if uri, ok := c.hl7ToFHIR[name]; ok {
		return uri
	}
	return name
}

// NewCodingSystemConvertor returns a new coding system converter based on the HL7Config,
func NewCodingSystemConvertor(hc *config.HL7Config) CodingSystemConvertor {
	return CodingSystemConvertor{
		hl7ToFHIR: hc.Mapping.FHIR.CodingSystems,
	}
}
